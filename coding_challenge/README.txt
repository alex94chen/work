README
קוד של השרת.
נעזרת בספריה של פייתון fastAPI שמאפשרת לי בקלות להרים שרת שמאזין לבקשות HTTP.
אני עושה זאת כדי לתת אפשרות לעובדים להשתמש בממשק של המשימות.
from fastapi import FastAPI, HTTPException
המודלים שאני מייבא הספריה:
FastAPI: מחלקה האחראית להגדיר את המסלולים (endpoints לדוגמא `/create_task/`) ואת הפונקציות המטפלות בהם. היא מייצגת את הבסיס התשתיותי של האפליקציה שלנו, והיא נוצרת על ידי יצירת מופע של המחלקה FastAPI.
HTTPException: מחלקה המשמשת לטיפול בחריגות HTTP בצורה מותאמת.

לאחר הייבוא של הספריה יצרתי אוביקט - שהוא מופע של המחלקה FastAPI לאוביקט קראתי "app".
 
שמירת הנתונים:
את הנתונים ניסיתי לשמור בDB של redis הרמתי קונטיינר מimag של redis שכבר מוכן מראש בדוקר.
ביצעתי עליו בדיקות בסיסיות שהוא מאזין מקבל נתונים שומר, מציג ומוחק.

**פיצר עתידי - אך בגלל קושי בליצור תקשורת ישירה מהפורט הפנימי של הקונטיינר של השרת לפורט של רידיס החלטתי לשמור את הנתונים ב-List פשוט של פיתון כאשר כל איבר הוא Tuple ובהמשך לשנות זאת לכך שהנתונים ישבו בDB מובנה של redis.(השימוש ב-List בפייתון פשוט ויעיל אבל זה על חשבון שמירה של נתונים מרובים וגדולים ולבצע פעולות מתקדמות)
השימוש ב-async מאפשר לפונקציה להתנהל ברקע ולאפשר למערכת להמשיך לעבוד גם בזמן שהפונקציה מבוצעת. 

כמה הנחת יסוד וישור קו במושגים:
לוודא שמותקן:uvicorn
*אני עובדת בCMD - כמובן שתוכל לעשות את הפעולות בכל ממשק CLI בהתאמה.
כאשר את משנה משהו בקוד הנתונים לא נשמרים ושוב תסמלץ מה שתרצה מחדש.

הרץ את השרת:
פתח CMD במקום בו שמור קובת main.py והרץ את הפקודה "uvicorn main:app --reload" 
1. `main`, אתה אומר ל-Uvicorn לחפש את הקובץ main.py בתיקיתה הנוכחית.
2. `app`, אתה אומר ל-Uvicorn למצוא את המשתנה app בקובץ ה-main.py ולהשתמש בו כשרת ה-HTTP.
3. `--reload`:מגדיר לשרת להתרענן אוטומטית כשיש שינויים בקוד - כדי שלא תצטרך שוב להריץ את הפקודה

לאחר מכן תכנס לקישור הזה:
http://127.0.0.1:8000/docs 
אם הקישור שהוספתי לא נפתח לך כראוי: ,תגש לCLI בו הרצת את הפקודה ובפלט שלה מופיע הכתובת IP של המחשב שלך עם הפורט שהשרת מאזין בו  תוסיף docs/.  

הערות:
כרגע אין ירידת שורה - בעתיד יהיה.
זה פלט לדוגמא של שני משימות זהות:
"title: t1 - description: 1 ==== title: t1 - description: 1"
אם המשימה לא עוצרת כשאתה רוצה לעצור תוכל לפתוח חלונית CMD נוספת ולהריץ את הפקודה:
taskkill /F /IM uvicorn.exe

כדי להריץ את השרת מדוקר:
יצרתי אימג ומימנו בהתחלה מופע יחיד:

docker build -t s_http .

לאחר מכן הוספתי עוד קונטינר (משתמש נוסף) 


בשלב הזה ראיתי ששני משתמשים יכולים לגשת לשרת - אבל הן לא מסונכרנים במידע כי הם שומרים על list שמיוצר בקוד שהם מריצים בתוך הקונטיינר. 
כדי שיהיו מסונכרנים בינהם בDB חזרתי לנסות לפתור זאת ע"י שימוש ברידיס.
**בשלב זה העלתי הכל לגיט כדי שהגרסה שעובדת**

בצעתי שינוי בקוד כך שהמידע יעבור במקום למבנה - list בפיתון לDB של redis
יבוא ספריה: import redis  
r=redis.StrictRedis(host='redis',port=6379,db=0,decode_responses=True)
בפונקציות טיפלתי בלוגיקה בהתאמה בכל מקום שבו עבדתי עם ה-list עברתי לעבוד עם הdb_redis
הרמתי קונטיינר של redis- (ברשת הפנימית המשותפת - my_network)

docker network create my_network
docker run -d --network my_network --name my_red redis 
אחרי שהקונטינר של רידיס רץ - וראיתי בלוגים שלו שהוא מאזין לבקשות 
בניתי את הimag מחדש (כי שיניתי את הקוד) ויצרתי 2 מופעים - גם מאותה הרשת:
docker run -p 8000:80 -it --network my_network imag_fastapi:latest
docker run -p 8080:80 -it --network my_network imag_fastapi:latest

בשלב הזה הדברים היו בפעולה 

השלב הבא הוא לבצע את כל הפעולות בצורה מסונכרנת בDB

אך השרתים לא הצליחו לשלוח בקשות לredis להלן השגיאה:
2023-08-15 00:58:08 redis.exceptions.ConnectionError: Error -3 connecting to redis:6379. Temporary failure in name resolution.